# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:11:13+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    AccessDeniedException,
    AssociateAwsAccountWithPartnerAccountResponse,
    AssociateMulticastGroupWithFuotaTaskResponse,
    AssociateWirelessDeviceWithFuotaTaskResponse,
    AssociateWirelessDeviceWithMulticastGroupResponse,
    AssociateWirelessDeviceWithThingResponse,
    AssociateWirelessGatewayWithCertificateResponse,
    AssociateWirelessGatewayWithThingResponse,
    CancelMulticastGroupSessionResponse,
    ConflictException,
    CreateDestinationResponse,
    CreateDeviceProfileResponse,
    CreateFuotaTaskResponse,
    CreateMulticastGroupResponse,
    CreateNetworkAnalyzerConfigurationResponse,
    CreateServiceProfileResponse,
    CreateWirelessDeviceResponse,
    CreateWirelessGatewayResponse,
    CreateWirelessGatewayTaskDefinitionResponse,
    CreateWirelessGatewayTaskResponse,
    DeleteDestinationResponse,
    DeleteDeviceProfileResponse,
    DeleteFuotaTaskResponse,
    DeleteMulticastGroupResponse,
    DeleteNetworkAnalyzerConfigurationResponse,
    DeleteQueuedMessagesResponse,
    DeleteServiceProfileResponse,
    DeleteWirelessDeviceImportTaskResponse,
    DeleteWirelessDeviceResponse,
    DeleteWirelessGatewayResponse,
    DeleteWirelessGatewayTaskDefinitionResponse,
    DeleteWirelessGatewayTaskResponse,
    DeregisterWirelessDeviceResponse,
    DestinationsNamePatchRequest,
    DestinationsPostRequest,
    DeviceProfilesPostRequest,
    DeviceProfileType,
    DisassociateAwsAccountFromPartnerAccountResponse,
    DisassociateMulticastGroupFromFuotaTaskResponse,
    DisassociateWirelessDeviceFromFuotaTaskResponse,
    DisassociateWirelessDeviceFromMulticastGroupResponse,
    DisassociateWirelessDeviceFromThingResponse,
    DisassociateWirelessGatewayFromCertificateResponse,
    DisassociateWirelessGatewayFromThingResponse,
    EventConfigurationsIdentifierIdentifierTypePatchRequest,
    EventConfigurationsResourceTypesPatchRequest,
    FuotaTasksIdMulticastGroupPutRequest,
    FuotaTasksIdPatchRequest,
    FuotaTasksIdPutRequest,
    FuotaTasksIdWirelessDevicePutRequest,
    FuotaTasksPostRequest,
    GetDestinationResponse,
    GetDeviceProfileResponse,
    GetEventConfigurationByResourceTypesResponse,
    GetFuotaTaskResponse,
    GetLogLevelsByResourceTypesResponse,
    GetMulticastGroupResponse,
    GetMulticastGroupSessionResponse,
    GetNetworkAnalyzerConfigurationResponse,
    GetPartnerAccountResponse,
    GetPositionConfigurationResponse,
    GetPositionEstimateResponse,
    GetPositionResponse,
    GetResourceEventConfigurationResponse,
    GetResourceLogLevelResponse,
    GetResourcePositionResponse,
    GetServiceEndpointResponse,
    GetServiceProfileResponse,
    GetWirelessDeviceImportTaskResponse,
    GetWirelessDeviceResponse,
    GetWirelessDeviceStatisticsResponse,
    GetWirelessGatewayCertificateResponse,
    GetWirelessGatewayFirmwareInformationResponse,
    GetWirelessGatewayResponse,
    GetWirelessGatewayStatisticsResponse,
    GetWirelessGatewayTaskDefinitionResponse,
    GetWirelessGatewayTaskResponse,
    IdentifierType,
    IdentifierType5,
    IdentifierType7,
    InternalServerException,
    ListDestinationsResponse,
    ListDeviceProfilesResponse,
    ListDevicesForWirelessDeviceImportTaskResponse,
    ListEventConfigurationsResponse,
    ListFuotaTasksResponse,
    ListMulticastGroupsByFuotaTaskResponse,
    ListMulticastGroupsResponse,
    ListNetworkAnalyzerConfigurationsResponse,
    ListPartnerAccountsResponse,
    ListPositionConfigurationsResponse,
    ListQueuedMessagesResponse,
    ListServiceProfilesResponse,
    ListTagsForResourceResponse,
    ListWirelessDeviceImportTasksResponse,
    ListWirelessDevicesResponse,
    ListWirelessGatewaysResponse,
    ListWirelessGatewayTaskDefinitionsResponse,
    LogLevelsPostRequest,
    LogLevelsResourceIdentifierResourceTypePutRequest,
    MulticastGroupsIdBulkPatchRequest,
    MulticastGroupsIdBulkPostRequest,
    MulticastGroupsIdDataPostRequest,
    MulticastGroupsIdPatchRequest,
    MulticastGroupsIdSessionPutRequest,
    MulticastGroupsIdWirelessDevicePutRequest,
    MulticastGroupsPostRequest,
    NetworkAnalyzerConfigurationsConfigurationNamePatchRequest,
    NetworkAnalyzerConfigurationsPostRequest,
    PartnerAccountsPartnerAccountIdPartnerTypePatchRequest,
    PartnerAccountsPostRequest,
    PartnerType,
    PositionConfigurationsResourceIdentifierResourceTypePutRequest,
    PositionEstimatePostRequest,
    PositionsResourceIdentifierResourceTypePatchRequest,
    PutPositionConfigurationResponse,
    PutResourceLogLevelResponse,
    ResetAllResourceLogLevelsResponse,
    ResetResourceLogLevelResponse,
    ResourceNotFoundException,
    ResourcePositionsResourceIdentifierResourceTypePatchRequest,
    ResourceType1,
    ResourceType3,
    SendDataToMulticastGroupResponse,
    SendDataToWirelessDeviceResponse,
    ServiceProfilesPostRequest,
    ServiceType,
    StartBulkAssociateWirelessDeviceWithMulticastGroupResponse,
    StartBulkDisassociateWirelessDeviceFromMulticastGroupResponse,
    StartFuotaTaskResponse,
    StartMulticastGroupSessionResponse,
    StartSingleWirelessDeviceImportTaskResponse,
    StartWirelessDeviceImportTaskResponse,
    Status,
    TagKeys,
    TagResourceResponse,
    TagsResourceArnPostRequest,
    TaskDefinitionType,
    TestWirelessDeviceResponse,
    ThrottlingException,
    TooManyTagsException,
    UntagResourceResponse,
    UpdateDestinationResponse,
    UpdateEventConfigurationByResourceTypesResponse,
    UpdateFuotaTaskResponse,
    UpdateLogLevelsByResourceTypesResponse,
    UpdateMulticastGroupResponse,
    UpdateNetworkAnalyzerConfigurationResponse,
    UpdatePartnerAccountResponse,
    UpdatePositionResponse,
    UpdateResourceEventConfigurationResponse,
    UpdateResourcePositionResponse,
    UpdateWirelessDeviceImportTaskResponse,
    UpdateWirelessDeviceResponse,
    UpdateWirelessGatewayResponse,
    ValidationException,
    WirelessDeviceImportTaskIdPatchRequest,
    WirelessDeviceImportTaskPostRequest,
    WirelessDevicesIdDataPostRequest,
    WirelessDevicesIdPatchRequest,
    WirelessDevicesIdThingPutRequest,
    WirelessDevicesPostRequest,
    WirelessDeviceType,
    WirelessGatewaysIdCertificatePutRequest,
    WirelessGatewaysIdPatchRequest,
    WirelessGatewaysIdTasksPostRequest,
    WirelessGatewaysIdThingPutRequest,
    WirelessGatewaysPostRequest,
    WirelessGatewayTaskDefinitionsPostRequest,
    WirelessSingleDeviceImportTaskPostRequest,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='<p>AWS IoT Wireless provides bi-directional communication between internet-connected wireless devices and the AWS Cloud. To onboard both LoRaWAN and Sidewalk devices to AWS IoT, use the IoT Wireless API. These wireless devices use the Low Power Wide Area Networking (LPWAN) communication protocol to communicate with AWS IoT.</p> <p>Using the API, you can perform create, read, update, and delete operations for your wireless devices, gateways, destinations, and profiles. After onboarding your devices, you can use the API operations to set log levels and monitor your devices with CloudWatch.</p> <p>You can also use the API operations to create multicast groups and schedule a multicast session for sending a downlink message to devices in the group. By using Firmware Updates Over-The-Air (FUOTA) API operations, you can create a FUOTA task and schedule a session to update the firmware of individual devices or an entire group of devices in a multicast group.</p>',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='AWS IoT Wireless',
    version='2020-11-22',
    servers=[
        {
            'description': 'The AWS IoT Wireless multi-region endpoint',
            'url': 'http://api.iotwireless.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWS IoT Wireless multi-region endpoint',
            'url': 'https://api.iotwireless.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWS IoT Wireless endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://api.iotwireless.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The AWS IoT Wireless endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://api.iotwireless.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/destinations',
    description=""" Lists the destinations registered to your AWS account. """,
    tags=['message_queue_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_destinations(
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/destinations',
    description=""" Creates a new destination that maps a device message to an AWS IoT rule. """,
    tags=['destination_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_destination(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DestinationsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/destinations/{Name}',
    description=""" Deletes a destination. """,
    tags=[
        'destination_management',
        'partner_account_management',
        'resource_logging_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_destination(
    name: constr(pattern=r'[a-zA-Z0-9-_]+', max_length=128) = Path(..., alias='Name'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/destinations/{Name}',
    description=""" Gets information about a destination. """,
    tags=['event_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_destination(
    name: constr(pattern=r'[a-zA-Z0-9-_]+', max_length=128) = Path(..., alias='Name'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/destinations/{Name}',
    description=""" Updates properties of a destination. """,
    tags=['destination_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_destination(
    name: constr(pattern=r'[a-zA-Z0-9-_]+', max_length=128) = Path(..., alias='Name'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DestinationsNamePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/device-profiles',
    description=""" Lists the device profiles registered to your AWS account. """,
    tags=['device_profile_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_device_profiles(
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    device_profile_type: Optional[DeviceProfileType] = Query(
        None, alias='deviceProfileType'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/device-profiles',
    description=""" Creates a new device profile. """,
    tags=['device_profile_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_device_profile(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DeviceProfilesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/device-profiles/{Id}',
    description=""" Deletes a device profile. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_device_profile(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/device-profiles/{Id}',
    description=""" Gets information about a device profile. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_device_profile(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/event-configurations#resourceType',
    description=""" List event configurations where at least one event topic has been enabled. """,
    tags=['wireless_device_management', 'resource_logging_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_event_configurations(
    resource_type: ResourceType1 = Query(..., alias='resourceType'),
    max_results: Optional[conint(ge=0, le=250)] = Query(None, alias='maxResults'),
    next_token: Optional[constr(max_length=4096)] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/event-configurations-resource-types',
    description=""" Get the event configuration based on resource types. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_event_configuration_by_resource_types(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/event-configurations-resource-types',
    description=""" Update the event configuration based on resource types. """,
    tags=['event_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_event_configuration_by_resource_types(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: EventConfigurationsResourceTypesPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/event-configurations/{Identifier}#identifierType',
    description=""" Get the event configuration for a particular resource identifier. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_resource_event_configuration(
    identifier: constr(max_length=256) = Path(..., alias='Identifier'),
    identifier_type: IdentifierType = Query(..., alias='identifierType'),
    partner_type: Optional[PartnerType] = Query(None, alias='partnerType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/event-configurations/{Identifier}#identifierType',
    description=""" Update the event configuration for a particular resource identifier. """,
    tags=['event_configuration_management', 'partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_resource_event_configuration(
    identifier: constr(max_length=256) = Path(..., alias='Identifier'),
    identifier_type: IdentifierType = Query(..., alias='identifierType'),
    partner_type: Optional[PartnerType] = Query(None, alias='partnerType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: EventConfigurationsIdentifierIdentifierTypePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/fuota-tasks',
    description=""" Lists the FUOTA tasks registered to your AWS account. """,
    tags=['message_queue_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_fuota_tasks(
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/fuota-tasks',
    description=""" Creates a FUOTA task. """,
    tags=['fuota_task_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_fuota_task(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: FuotaTasksPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/fuota-tasks/{Id}',
    description=""" Deletes a FUOTA task. """,
    tags=['destination_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_fuota_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/fuota-tasks/{Id}',
    description=""" Gets information about a FUOTA task. """,
    tags=['wireless_device_management', 'wireless_gateway_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_fuota_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/fuota-tasks/{Id}',
    description=""" Updates properties of a FUOTA task. """,
    tags=['fuota_task_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_fuota_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: FuotaTasksIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/fuota-tasks/{Id}',
    description=""" Starts a FUOTA task. """,
    tags=['fuota_task_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_fuota_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: FuotaTasksIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/fuota-tasks/{Id}/multicast-group',
    description=""" Associate a multicast group with a FUOTA task. """,
    tags=['fuota_task_management', 'multicast_group_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_multicast_group_with_fuota_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: FuotaTasksIdMulticastGroupPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/fuota-tasks/{Id}/multicast-groups',
    description=""" List all multicast groups associated with a fuota task. """,
    tags=['destination_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_multicast_groups_by_fuota_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/fuota-tasks/{Id}/multicast-groups/{MulticastGroupId}',
    description=""" Disassociates a multicast group from a fuota task. """,
    tags=['multicast_group_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_multicast_group_from_fuota_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    multicast_group_id: constr(max_length=256) = Path(..., alias='MulticastGroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/fuota-tasks/{Id}/wireless-device',
    description=""" Associate a wireless device with a FUOTA task. """,
    tags=['fuota_task_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_wireless_device_with_fuota_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: FuotaTasksIdWirelessDevicePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/fuota-tasks/{Id}/wireless-devices/{WirelessDeviceId}',
    description=""" Disassociates a wireless device from a FUOTA task. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_wireless_device_from_fuota_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    wireless_device_id: constr(max_length=256) = Path(..., alias='WirelessDeviceId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/log-levels',
    description=""" Removes the log-level overrides for all resources; both wireless devices and wireless gateways. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def reset_all_resource_log_levels(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/log-levels',
    description=""" Returns current default log levels or log levels by resource types. Based on resource types, log levels can be for wireless device log options or wireless gateway log options. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_log_levels_by_resource_types(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/log-levels',
    description=""" Set default log level, or log levels by resource types. This can be for wireless device log options or wireless gateways log options and is used to control the log messages that'll be displayed in CloudWatch. """,
    tags=['log_level_management', 'resource_logging_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_log_levels_by_resource_types(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: LogLevelsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/log-levels/{ResourceIdentifier}#resourceType',
    description=""" Removes the log-level override, if any, for a specific resource-ID and resource-type. It can be used for a wireless device or a wireless gateway. """,
    tags=['resource_tagging_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def reset_resource_log_level(
    resource_identifier: constr(max_length=256) = Path(..., alias='ResourceIdentifier'),
    resource_type: str = Query(..., alias='resourceType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/log-levels/{ResourceIdentifier}#resourceType',
    description=""" Fetches the log-level override, if any, for a given resource-ID and resource-type. It can be used for a wireless device or a wireless gateway. """,
    tags=['resource_logging_management', 'resource_tagging_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_resource_log_level(
    resource_identifier: constr(max_length=256) = Path(..., alias='ResourceIdentifier'),
    resource_type: str = Query(..., alias='resourceType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/log-levels/{ResourceIdentifier}#resourceType',
    description=""" Sets the log-level override for a resource-ID and resource-type. This option can be specified for a wireless gateway or a wireless device. A limit of 200 log level override can be set per account. """,
    tags=['resource_logging_management', 'log_level_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_resource_log_level(
    resource_identifier: constr(max_length=256) = Path(..., alias='ResourceIdentifier'),
    resource_type: str = Query(..., alias='resourceType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: LogLevelsResourceIdentifierResourceTypePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/multicast-groups',
    description=""" Lists the multicast groups registered to your AWS account. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_multicast_groups(
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/multicast-groups',
    description=""" Creates a multicast group. """,
    tags=['multicast_group_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_multicast_group(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: MulticastGroupsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/multicast-groups/{Id}',
    description=""" Deletes a multicast group if it is not in use by a fuota task. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_multicast_group(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/multicast-groups/{Id}',
    description=""" Gets information about a multicast group. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_multicast_group(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/multicast-groups/{Id}',
    description=""" Updates properties of a multicast group session. """,
    tags=['multicast_group_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_multicast_group(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: MulticastGroupsIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/multicast-groups/{Id}/bulk',
    description=""" Starts a bulk association of all qualifying wireless devices with a multicast group. """,
    tags=['multicast_group_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_bulk_associate_wireless_device_with_multicast_group(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: MulticastGroupsIdBulkPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/multicast-groups/{Id}/bulk',
    description=""" Starts a bulk disassociatin of all qualifying wireless devices from a multicast group. """,
    tags=['multicast_group_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_bulk_disassociate_wireless_device_from_multicast_group(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: MulticastGroupsIdBulkPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/multicast-groups/{Id}/data',
    description=""" Sends the specified data to a multicast group. """,
    tags=['multicast_group_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def send_data_to_multicast_group(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: MulticastGroupsIdDataPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/multicast-groups/{Id}/session',
    description=""" Cancels an existing multicast group session. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def cancel_multicast_group_session(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/multicast-groups/{Id}/session',
    description=""" Gets information about a multicast group session. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_multicast_group_session(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/multicast-groups/{Id}/session',
    description=""" Starts a multicast group session. """,
    tags=['multicast_group_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_multicast_group_session(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: MulticastGroupsIdSessionPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/multicast-groups/{Id}/wireless-device',
    description=""" Associates a wireless device with a multicast group. """,
    tags=['multicast_group_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_wireless_device_with_multicast_group(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: MulticastGroupsIdWirelessDevicePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/multicast-groups/{Id}/wireless-devices/{WirelessDeviceId}',
    description=""" Disassociates a wireless device from a multicast group. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_wireless_device_from_multicast_group(
    id: constr(max_length=256) = Path(..., alias='Id'),
    wireless_device_id: constr(max_length=256) = Path(..., alias='WirelessDeviceId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-analyzer-configurations',
    description=""" Lists the network analyzer configurations. """,
    tags=['message_queue_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_network_analyzer_configurations(
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/network-analyzer-configurations',
    description=""" Creates a new network analyzer configuration. """,
    tags=['network_analyzer_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_network_analyzer_configuration(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: NetworkAnalyzerConfigurationsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/network-analyzer-configurations/{ConfigurationName}',
    description=""" Deletes a network analyzer configuration. """,
    tags=['event_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_network_analyzer_configuration(
    configuration_name: constr(
        pattern=r'[a-zA-Z0-9-_]+', min_length=1, max_length=1024
    ) = Path(..., alias='ConfigurationName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-analyzer-configurations/{ConfigurationName}',
    description=""" Get network analyzer configuration. """,
    tags=['event_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_network_analyzer_configuration(
    configuration_name: constr(
        pattern=r'[a-zA-Z0-9-_]+', min_length=1, max_length=1024
    ) = Path(..., alias='ConfigurationName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/network-analyzer-configurations/{ConfigurationName}',
    description=""" Update network analyzer configuration. """,
    tags=['network_analyzer_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_network_analyzer_configuration(
    configuration_name: constr(
        pattern=r'[a-zA-Z0-9-_]+', min_length=1, max_length=1024
    ) = Path(..., alias='ConfigurationName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: NetworkAnalyzerConfigurationsConfigurationNamePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/partner-accounts',
    description=""" Lists the partner accounts associated with your AWS account. """,
    tags=['destination_management', 'message_queue_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_partner_accounts(
    next_token: Optional[constr(max_length=4096)] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=0, le=250)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/partner-accounts',
    description=""" Associates a partner account with your AWS account. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_aws_account_with_partner_account(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: PartnerAccountsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/partner-accounts/{PartnerAccountId}#partnerType',
    description=""" Disassociates your AWS account from a partner account. If <code>PartnerAccountId</code> and <code>PartnerType</code> are <code>null</code>, disassociates your AWS account from all partner accounts. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_aws_account_from_partner_account(
    partner_account_id: constr(max_length=256) = Path(..., alias='PartnerAccountId'),
    partner_type: PartnerType = Query(..., alias='partnerType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/partner-accounts/{PartnerAccountId}#partnerType',
    description=""" Gets information about a partner account. If <code>PartnerAccountId</code> and <code>PartnerType</code> are <code>null</code>, returns all partner accounts. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_partner_account(
    partner_account_id: constr(max_length=256) = Path(..., alias='PartnerAccountId'),
    partner_type: PartnerType = Query(..., alias='partnerType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/partner-accounts/{PartnerAccountId}#partnerType',
    description=""" Updates properties of a partner account. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_partner_account(
    partner_account_id: constr(max_length=256) = Path(..., alias='PartnerAccountId'),
    partner_type: PartnerType = Query(..., alias='partnerType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: PartnerAccountsPartnerAccountIdPartnerTypePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/position-configurations',
    description=""" <p>List position configurations for a given resource, such as positioning solvers.</p> <important> <p>This action is no longer supported. Calls to retrieve position information should use the <a href="https://docs.aws.amazon.com/iot-wireless/2020-11-22/apireference/API_GetResourcePosition.html">GetResourcePosition</a> API operation instead.</p> </important> """,
    tags=[
        'destination_management',
        'resource_tagging_management',
        'wireless_device_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_position_configurations(
    resource_type: Optional[ResourceType3] = Query(None, alias='resourceType'),
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/position-configurations/{ResourceIdentifier}#resourceType',
    description=""" <p>Get position configuration for a given resource.</p> <important> <p>This action is no longer supported. Calls to retrieve the position configuration should use the <a href="https://docs.aws.amazon.com/iot-wireless/2020-11-22/apireference/API_GetResourcePosition.html">GetResourcePosition</a> API operation instead.</p> </important> """,
    tags=['resource_logging_management', 'resource_tagging_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_position_configuration(
    resource_identifier: constr(
        pattern=r'[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'
    ) = Path(..., alias='ResourceIdentifier'),
    resource_type: ResourceType3 = Query(..., alias='resourceType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/position-configurations/{ResourceIdentifier}#resourceType',
    description=""" <p>Put position configuration for a given resource.</p> <important> <p>This action is no longer supported. Calls to update the position configuration should use the <a href="https://docs.aws.amazon.com/iot-wireless/2020-11-22/apireference/API_UpdateResourcePosition.html">UpdateResourcePosition</a> API operation instead.</p> </important> """,
    tags=['position_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_position_configuration(
    resource_identifier: constr(
        pattern=r'[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'
    ) = Path(..., alias='ResourceIdentifier'),
    resource_type: ResourceType3 = Query(..., alias='resourceType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: PositionConfigurationsResourceIdentifierResourceTypePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/position-estimate',
    description=""" Get estimated position information as a payload in GeoJSON format. The payload measurement data is resolved using solvers that are provided by third-party vendors. """,
    tags=['position_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_position_estimate(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: PositionEstimatePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/positions/{ResourceIdentifier}#resourceType',
    description=""" <p>Get the position information for a given resource.</p> <important> <p>This action is no longer supported. Calls to retrieve the position information should use the <a href="https://docs.aws.amazon.com/iot-wireless/2020-11-22/apireference/API_GetResourcePosition.html">GetResourcePosition</a> API operation instead.</p> </important> """,
    tags=['resource_logging_management', 'resource_tagging_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_position(
    resource_identifier: constr(
        pattern=r'[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'
    ) = Path(..., alias='ResourceIdentifier'),
    resource_type: ResourceType3 = Query(..., alias='resourceType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/positions/{ResourceIdentifier}#resourceType',
    description=""" <p>Update the position information of a resource.</p> <important> <p>This action is no longer supported. Calls to update the position information should use the <a href="https://docs.aws.amazon.com/iot-wireless/2020-11-22/apireference/API_UpdateResourcePosition.html">UpdateResourcePosition</a> API operation instead.</p> </important> """,
    tags=['resource_position_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_position(
    resource_identifier: constr(
        pattern=r'[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'
    ) = Path(..., alias='ResourceIdentifier'),
    resource_type: ResourceType3 = Query(..., alias='resourceType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: PositionsResourceIdentifierResourceTypePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/resource-positions/{ResourceIdentifier}#resourceType',
    description=""" Get the position information for a given wireless device or a wireless gateway resource. The position information uses the <a href="https://gisgeography.com/wgs84-world-geodetic-system/"> World Geodetic System (WGS84)</a>. """,
    tags=[
        'resource_logging_management',
        'resource_tagging_management',
        'wireless_device_management',
        'wireless_gateway_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_resource_position(
    resource_identifier: constr(
        pattern=r'[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'
    ) = Path(..., alias='ResourceIdentifier'),
    resource_type: ResourceType3 = Query(..., alias='resourceType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/resource-positions/{ResourceIdentifier}#resourceType',
    description=""" Update the position information of a given wireless device or a wireless gateway resource. The position coordinates are based on the <a href="https://gisgeography.com/wgs84-world-geodetic-system/"> World Geodetic System (WGS84)</a>. """,
    tags=['resource_position_management', 'position_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_resource_position(
    resource_identifier: constr(
        pattern=r'[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'
    ) = Path(..., alias='ResourceIdentifier'),
    resource_type: ResourceType3 = Query(..., alias='resourceType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ResourcePositionsResourceIdentifierResourceTypePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/service-endpoint',
    description=""" Gets the account-specific endpoint for Configuration and Update Server (CUPS) protocol or LoRaWAN Network Server (LNS) connections. """,
    tags=['service_profile_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_service_endpoint(
    service_type: Optional[ServiceType] = Query(None, alias='serviceType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/service-profiles',
    description=""" Lists the service profiles registered to your AWS account. """,
    tags=[
        'destination_management',
        'event_configuration_management',
        'wireless_device_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_service_profiles(
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/service-profiles',
    description=""" Creates a new service profile. """,
    tags=['service_profile_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_service_profile(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ServiceProfilesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/service-profiles/{Id}',
    description=""" Deletes a service profile. """,
    tags=['wireless_device_management', 'wireless_gateway_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_service_profile(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/service-profiles/{Id}',
    description=""" Gets information about a service profile. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_service_profile(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags#resourceArn',
    description=""" Lists the tags (metadata) you have assigned to the resource. """,
    tags=['resource_tagging_management', 'resource_logging_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    resource_arn: constr(min_length=1, max_length=1011) = Query(
        ..., alias='resourceArn'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags#resourceArn',
    description=""" Adds a tag to a resource. """,
    tags=['resource_tagging_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: constr(min_length=1, max_length=1011) = Query(
        ..., alias='resourceArn'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: TagsResourceArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags#resourceArn&tagKeys',
    description=""" Removes one or more tags from a resource. """,
    tags=['resource_tagging_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: constr(min_length=1, max_length=1011) = Query(
        ..., alias='resourceArn'
    ),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-devices',
    description=""" Lists the wireless devices registered to your AWS account. """,
    tags=[
        'fuota_task_management',
        'multicast_group_management',
        'device_profile_management',
        'service_profile_management',
        'wireless_device_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_wireless_devices(
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    destination_name: Optional[
        constr(pattern=r'[a-zA-Z0-9-_]+', max_length=128)
    ] = Query(None, alias='destinationName'),
    device_profile_id: Optional[constr(max_length=256)] = Query(
        None, alias='deviceProfileId'
    ),
    service_profile_id: Optional[constr(max_length=256)] = Query(
        None, alias='serviceProfileId'
    ),
    wireless_device_type: Optional[WirelessDeviceType] = Query(
        None, alias='wirelessDeviceType'
    ),
    fuota_task_id: Optional[constr(max_length=256)] = Query(None, alias='fuotaTaskId'),
    multicast_group_id: Optional[constr(max_length=256)] = Query(
        None, alias='multicastGroupId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wireless-devices',
    description=""" Provisions a wireless device. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_wireless_device(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessDevicesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-devices/{Identifier}#identifierType',
    description=""" Gets information about a wireless device. """,
    tags=['wireless_device_management', 'service_profile_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_wireless_device(
    identifier: constr(max_length=256) = Path(..., alias='Identifier'),
    identifier_type: IdentifierType5 = Query(..., alias='identifierType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/wireless-devices/{Identifier}/deregister',
    description=""" Deregister a wireless device from AWS IoT Wireless. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def deregister_wireless_device(
    identifier: constr(max_length=256) = Path(..., alias='Identifier'),
    wireless_device_type: Optional[WirelessDeviceType] = Query(
        None, alias='WirelessDeviceType'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/wireless-devices/{Id}',
    description=""" Deletes a wireless device. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_wireless_device(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/wireless-devices/{Id}',
    description=""" Updates properties of a wireless device. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_wireless_device(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessDevicesIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-devices/{Id}/data',
    description=""" List queued messages in the downlink queue. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_queued_messages(
    id: constr(max_length=256) = Path(..., alias='Id'),
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    wireless_device_type: Optional[WirelessDeviceType] = Query(
        None, alias='WirelessDeviceType'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wireless-devices/{Id}/data',
    description=""" Sends a decrypted application data frame to a device. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def send_data_to_wireless_device(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessDevicesIdDataPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/wireless-devices/{Id}/data#messageId',
    description=""" Remove queued messages from the downlink queue. """,
    tags=['message_queue_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_queued_messages(
    id: constr(max_length=256) = Path(..., alias='Id'),
    message_id: str = Query(..., alias='messageId'),
    wireless_device_type: Optional[WirelessDeviceType] = Query(
        None, alias='WirelessDeviceType'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-devices/{Id}/statistics',
    description=""" Gets operating information about a wireless device. """,
    tags=['service_profile_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_wireless_device_statistics(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wireless-devices/{Id}/test',
    description=""" Simulates a provisioned device by sending an uplink data payload of <code>Hello</code>. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def test_wireless_device(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/wireless-devices/{Id}/thing',
    description=""" Disassociates a wireless device from its currently associated thing. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_wireless_device_from_thing(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/wireless-devices/{Id}/thing',
    description=""" Associates a wireless device with a thing. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_wireless_device_with_thing(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessDevicesIdThingPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-gateway-task-definitions',
    description=""" List the wireless gateway tasks definitions registered to your AWS account. """,
    tags=['fuota_task_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_wireless_gateway_task_definitions(
    max_results: Optional[conint(ge=0, le=250)] = Query(None, alias='maxResults'),
    next_token: Optional[constr(max_length=4096)] = Query(None, alias='nextToken'),
    task_definition_type: Optional[TaskDefinitionType] = Query(
        None, alias='taskDefinitionType'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wireless-gateway-task-definitions',
    description=""" Creates a gateway task definition. """,
    tags=['wireless_gateway_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_wireless_gateway_task_definition(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessGatewayTaskDefinitionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/wireless-gateway-task-definitions/{Id}',
    description=""" Deletes a wireless gateway task definition. Deleting this task definition does not affect tasks that are currently in progress. """,
    tags=['destination_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_wireless_gateway_task_definition(
    id: constr(
        pattern=r'[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}',
        max_length=36,
    ) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-gateway-task-definitions/{Id}',
    description=""" Gets information about a wireless gateway task definition. """,
    tags=['service_profile_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_wireless_gateway_task_definition(
    id: constr(
        pattern=r'[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}',
        max_length=36,
    ) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-gateways',
    description=""" Lists the wireless gateways registered to your AWS account. """,
    tags=['destination_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_wireless_gateways(
    next_token: Union[
        Optional[constr(max_length=4096)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    max_results: Union[
        Optional[conint(ge=0, le=250)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wireless-gateways',
    description=""" Provisions a wireless gateway. """,
    tags=['wireless_gateway_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_wireless_gateway(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessGatewaysPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-gateways/{Identifier}#identifierType',
    description=""" Gets information about a wireless gateway. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_wireless_gateway(
    identifier: constr(max_length=256) = Path(..., alias='Identifier'),
    identifier_type: IdentifierType7 = Query(..., alias='identifierType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/wireless-gateways/{Id}',
    description=""" Deletes a wireless gateway. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_wireless_gateway(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/wireless-gateways/{Id}',
    description=""" Updates properties of a wireless gateway. """,
    tags=['wireless_gateway_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_wireless_gateway(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessGatewaysIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/wireless-gateways/{Id}/certificate',
    description=""" Disassociates a wireless gateway from its currently associated certificate. """,
    tags=['resource_logging_management', 'resource_position_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_wireless_gateway_from_certificate(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-gateways/{Id}/certificate',
    description=""" Gets the ID of the certificate that is currently associated with a wireless gateway. """,
    tags=['device_profile_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_wireless_gateway_certificate(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/wireless-gateways/{Id}/certificate',
    description=""" Associates a wireless gateway with a certificate. """,
    tags=['wireless_gateway_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_wireless_gateway_with_certificate(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessGatewaysIdCertificatePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-gateways/{Id}/firmware-information',
    description=""" Gets the firmware version and other information about a wireless gateway. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_wireless_gateway_firmware_information(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-gateways/{Id}/statistics',
    description=""" Gets operating information about a wireless gateway. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_wireless_gateway_statistics(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/wireless-gateways/{Id}/tasks',
    description=""" Deletes a wireless gateway task. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_wireless_gateway_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless-gateways/{Id}/tasks',
    description=""" Gets information about a wireless gateway task. """,
    tags=['wireless_gateway_management', 'resource_logging_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_wireless_gateway_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wireless-gateways/{Id}/tasks',
    description=""" Creates a task for a wireless gateway. """,
    tags=['wireless_gateway_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_wireless_gateway_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessGatewaysIdTasksPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/wireless-gateways/{Id}/thing',
    description=""" Disassociates a wireless gateway from its currently associated thing. """,
    tags=['destination_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_wireless_gateway_from_thing(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/wireless-gateways/{Id}/thing',
    description=""" Associates a wireless gateway with a thing. """,
    tags=['wireless_gateway_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_wireless_gateway_with_thing(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessGatewaysIdThingPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wireless_device_import_task',
    description=""" Start import task for provisioning Sidewalk devices in bulk using an S3 CSV file. """,
    tags=['wireless_device_import_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_wireless_device_import_task(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessDeviceImportTaskPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless_device_import_task#id',
    description=""" List the Sidewalk devices in an import task and their onboarding status. """,
    tags=['destination_management', 'wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_devices_for_wireless_device_import_task(
    id: constr(max_length=256),
    max_results: Optional[conint(ge=0, le=250)] = Query(None, alias='maxResults'),
    next_token: Optional[constr(max_length=4096)] = Query(None, alias='nextToken'),
    status: Optional[Status] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/wireless_device_import_task/{Id}',
    description=""" Delete an import task. """,
    tags=['partner_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_wireless_device_import_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless_device_import_task/{Id}',
    description=""" Get information about an import task and count of device onboarding summary information for the import task. """,
    tags=['wireless_device_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_wireless_device_import_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/wireless_device_import_task/{Id}',
    description=""" Update an import task to add more devices to the task. """,
    tags=['wireless_device_import_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_wireless_device_import_task(
    id: constr(max_length=256) = Path(..., alias='Id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessDeviceImportTaskIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless_device_import_tasks',
    description=""" List wireless devices that have been added to an import task. """,
    tags=['message_queue_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_wireless_device_import_tasks(
    max_results: Optional[conint(ge=0, le=250)] = Query(None, alias='maxResults'),
    next_token: Optional[constr(max_length=4096)] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wireless_single_device_import_task',
    description=""" Start import task for a single wireless device. """,
    tags=['wireless_device_import_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_single_wireless_device_import_task(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WirelessSingleDeviceImportTaskPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
